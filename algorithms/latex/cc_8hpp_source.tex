\hypertarget{cc_8hpp_source}{}\doxysection{cc.\+hpp}
\label{cc_8hpp_source}\index{cc.hpp@{cc.hpp}}
\mbox{\hyperlink{cc_8hpp}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 }
\DoxyCodeLine{12 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include "{}../../src/gb\_kun.h"{}}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include "{}../../src/cpp\_graphblas/types.hpp"{}}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#define MASK\_NULL static\_cast<const lablas::Vector<float>*>(NULL)}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17 }
\DoxyCodeLine{19 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacelablas}{lablas}} \{}
\DoxyCodeLine{21     \textcolor{keyword}{namespace }algorithm \{}
\DoxyCodeLine{22 }
\DoxyCodeLine{32 \textcolor{keywordtype}{void} \mbox{\hyperlink{namespacelablas_1_1algorithm_a08966dc886244fb5d03bd0a4cbb9c4c3}{cc}}(Vector<int>*       v,}
\DoxyCodeLine{33         \textcolor{keyword}{const} Matrix<int> *A,}
\DoxyCodeLine{34         \textcolor{keywordtype}{int} seed,}
\DoxyCodeLine{35         Descriptor *desc)}
\DoxyCodeLine{36 \{}
\DoxyCodeLine{37     Index A\_nrows;}
\DoxyCodeLine{38     A-\/>get\_nrows(\&A\_nrows);}
\DoxyCodeLine{39     \textcolor{comment}{// Difference vector.}}
\DoxyCodeLine{40     Vector<bool> diff(A\_nrows);}
\DoxyCodeLine{41 }
\DoxyCodeLine{42     \textcolor{comment}{// Parent vector.}}
\DoxyCodeLine{43     \textcolor{comment}{// f in Zhang paper.}}
\DoxyCodeLine{44     Vector<int> parent(A\_nrows);}
\DoxyCodeLine{45     Vector<int> parent\_temp(A\_nrows);}
\DoxyCodeLine{46 }
\DoxyCodeLine{47     \textcolor{comment}{// Grandparent vector.}}
\DoxyCodeLine{48     \textcolor{comment}{// gf in Zhang paper.}}
\DoxyCodeLine{49     Vector<int> grandparent(A\_nrows);}
\DoxyCodeLine{50     Vector<int> grandparent\_temp(A\_nrows);}
\DoxyCodeLine{51 }
\DoxyCodeLine{52     \textcolor{comment}{// Min neighbor grandparent vector.}}
\DoxyCodeLine{53     \textcolor{comment}{// mngf in Zhang paper.}}
\DoxyCodeLine{54     Vector<int> min\_neighbor\_parent(A\_nrows);}
\DoxyCodeLine{55     Vector<int> min\_neighbor\_parent\_temp(A\_nrows);}
\DoxyCodeLine{56 }
\DoxyCodeLine{57     \textcolor{comment}{// Initialize parent and min\_neighbor\_parent to:}}
\DoxyCodeLine{58     \textcolor{comment}{// [0]:0 [1]:1 [2]:2 [3]:3 [4]:4, etc.}}
\DoxyCodeLine{59     parent.fillAscending(A\_nrows);}
\DoxyCodeLine{60 \textcolor{comment}{//    parent.print();}}
\DoxyCodeLine{61     min\_neighbor\_parent.dup(\&parent);}
\DoxyCodeLine{62 \textcolor{comment}{//    min\_neighbor\_parent.print();}}
\DoxyCodeLine{63     min\_neighbor\_parent\_temp.dup(\&parent);}
\DoxyCodeLine{64 \textcolor{comment}{//    min\_neighbor\_parent\_temp.print();}}
\DoxyCodeLine{65     grandparent.dup(\&parent);}
\DoxyCodeLine{66 \textcolor{comment}{//    grandparent.print();}}
\DoxyCodeLine{67     grandparent\_temp.dup(\&parent);}
\DoxyCodeLine{68 \textcolor{comment}{//    grandparent\_temp.print();}}
\DoxyCodeLine{69 }
\DoxyCodeLine{70     Index succ = 0;}
\DoxyCodeLine{71     \textcolor{keywordtype}{float} gpu\_tight\_time = 0.f;}
\DoxyCodeLine{72     Index niter = 100;}
\DoxyCodeLine{73     Index iter = 0;}
\DoxyCodeLine{74 }
\DoxyCodeLine{75     \textcolor{keywordflow}{for} (iter = 1; iter <= niter; ++iter) \{}
\DoxyCodeLine{76         \textcolor{comment}{// Duplicate parent.}}
\DoxyCodeLine{77         parent\_temp.dup(\&parent);}
\DoxyCodeLine{78 }
\DoxyCodeLine{79         \textcolor{comment}{// 1) Stochastic hooking.}}
\DoxyCodeLine{80         \textcolor{comment}{// mngf[u] = A x gf}}
\DoxyCodeLine{81         mxv(\&min\_neighbor\_parent\_temp, MASK\_NULL, GrB\_NULL,}
\DoxyCodeLine{82             MinimumSelectSecondSemiring<int>(), A, \&grandparent, desc);}
\DoxyCodeLine{83 }
\DoxyCodeLine{84         \textcolor{comment}{//cout << "{}min\_neighbor\_parent\_temp: "{};}}
\DoxyCodeLine{85         \textcolor{comment}{//min\_neighbor\_parent\_temp.print();}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87         eWiseAdd(\&min\_neighbor\_parent, MASK\_NULL, GrB\_NULL,}
\DoxyCodeLine{88                  MinimumSelectSecondSemiring<int>(), \&min\_neighbor\_parent, \&min\_neighbor\_parent\_temp, desc);}
\DoxyCodeLine{89 }
\DoxyCodeLine{90         \textcolor{comment}{//cout << "{}min\_neighbor\_paren: "{};}}
\DoxyCodeLine{91         \textcolor{comment}{//min\_neighbor\_parent.print();}}
\DoxyCodeLine{92 }
\DoxyCodeLine{93         \textcolor{comment}{// f[f[u]] = mngf[u]. Second does nothing (imitating comma operator)}}
\DoxyCodeLine{94         assignScatter(\&parent, MASK\_NULL, GrB\_NULL,}
\DoxyCodeLine{95                       \&min\_neighbor\_parent, \&parent\_temp, parent\_temp.nvals(), desc);}
\DoxyCodeLine{96 }
\DoxyCodeLine{97         \textcolor{comment}{//cout << "{}after assign: "{};}}
\DoxyCodeLine{98         \textcolor{comment}{//parent.print();}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100         \textcolor{comment}{// 2) Aggressive hooking.}}
\DoxyCodeLine{101         \textcolor{comment}{// f = min(f, mngf)}}
\DoxyCodeLine{102         eWiseAdd(\&parent, MASK\_NULL, GrB\_NULL,MinimumPlusSemiring<int>(), \&parent, \&min\_neighbor\_parent, desc);}
\DoxyCodeLine{103 }
\DoxyCodeLine{104         \textcolor{comment}{//cout << "{}after hooking: "{};}}
\DoxyCodeLine{105         \textcolor{comment}{//parent.print();}}
\DoxyCodeLine{106 }
\DoxyCodeLine{107         \textcolor{comment}{// 3) Shortcutting.}}
\DoxyCodeLine{108         \textcolor{comment}{// f = min(f, gf)}}
\DoxyCodeLine{109         eWiseAdd(\&parent, MASK\_NULL, GrB\_NULL, MinimumPlusSemiring<int>(), \&parent, \&parent\_temp, desc);}
\DoxyCodeLine{110 }
\DoxyCodeLine{111         \textcolor{comment}{// 4) Calculate grandparents.}}
\DoxyCodeLine{112         \textcolor{comment}{// gf[u] = f[f[u]]}}
\DoxyCodeLine{113         extract(\&grandparent, MASK\_NULL, GrB\_NULL, \&parent, \&parent, desc);}
\DoxyCodeLine{114 }
\DoxyCodeLine{115         \textcolor{comment}{// 5) Check termination.}}
\DoxyCodeLine{116         eWiseMult(\&diff, MASK\_NULL, GrB\_NULL,}
\DoxyCodeLine{117                   MinimumNotEqualToSemiring<int, int, bool>(), \&grandparent\_temp, \&grandparent, desc);}
\DoxyCodeLine{118         reduce<Index, bool>(\&succ, GrB\_NULL, PlusMonoid<Index>(), \&diff, desc);}
\DoxyCodeLine{119 \textcolor{preprocessor}{        \#ifdef \_\_DEBUG\_INFO\_\_}}
\DoxyCodeLine{120         cout << \textcolor{stringliteral}{"{}succ: "{}} << succ << endl;}
\DoxyCodeLine{121 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{122         \textcolor{keywordflow}{if} (succ == 0)}
\DoxyCodeLine{123         \{}
\DoxyCodeLine{124             \textcolor{keywordflow}{break};}
\DoxyCodeLine{125         \}}
\DoxyCodeLine{126         grandparent\_temp.dup(\&grandparent);}
\DoxyCodeLine{127 }
\DoxyCodeLine{128         \textcolor{comment}{// 6) Similar to BFS and SSSP, we should filter out the unproductive}}
\DoxyCodeLine{129         \textcolor{comment}{// vertices from the next iteration.}}
\DoxyCodeLine{130         desc-\/>toggle(GrB\_MASK);}
\DoxyCodeLine{131         assign(\&grandparent, \&diff, \textcolor{keyword}{nullptr},}
\DoxyCodeLine{132                                     std::numeric\_limits<int>::max(), GrB\_ALL, A\_nrows, desc);}
\DoxyCodeLine{133         desc-\/>toggle(GrB\_MASK);}
\DoxyCodeLine{134         Desc\_value a;}
\DoxyCodeLine{135         desc-\/>get(GrB\_MASK, \&a);}
\DoxyCodeLine{136     \}}
\DoxyCodeLine{137     v-\/>dup(\&parent);}
\DoxyCodeLine{138     std::cout << \textcolor{stringliteral}{"{}Did "{}} << iter <<  \textcolor{stringliteral}{"{} iterations"{}} << std::endl;}
\DoxyCodeLine{139 \}}
\DoxyCodeLine{140 }
\DoxyCodeLine{141 \}  \textcolor{comment}{// namespace algorithm}}
\DoxyCodeLine{142 \}  \textcolor{comment}{// namespace graphblas}}

\end{DoxyCode}
